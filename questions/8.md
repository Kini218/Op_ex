# Унаследованные и переопределенные методы. Перегрузка методов – частный случай полиморфизма.

### **Унаследованные и переопределенные методы**

---

### **1. Унаследованные методы**
- Методы базового класса автоматически доступны в производных классах.
- Если метод в базовом классе **не переопределяется**, то он используется в производном классе "как есть".

#### Пример:
```csharp
public class Animal
{
    public void Eat()
    {
        Console.WriteLine("Animal is eating.");
    }
}

public class Dog : Animal
{
    // Dog унаследовал метод Eat
}

Dog dog = new Dog();
dog.Eat(); // Вывод: Animal is eating.
```

---

### **2. Переопределенные методы**

#### **Переопределение методов (`override`)**
- Для переопределения метода в производном классе он должен быть объявлен с ключевым словом `virtual` или `abstract` в базовом классе.
- В производном классе используется ключевое слово `override`.

#### Пример:
```csharp
public class Animal
{
    public virtual void Speak()
    {
        Console.WriteLine("Animal makes a sound.");
    }
}

public class Dog : Animal
{
    public override void Speak()
    {
        Console.WriteLine("Dog barks.");
    }
}

Animal animal = new Animal();
animal.Speak(); // Вывод: Animal makes a sound.

Dog dog = new Dog();
dog.Speak(); // Вывод: Dog barks.
```

#### **Использование `base` для вызова метода базового класса**
Производный класс может вызвать метод базового класса через ключевое слово `base`.

```csharp
public class Dog : Animal
{
    public override void Speak()
    {
        base.Speak(); // Вызов базового метода
        Console.WriteLine("Dog barks.");
    }
}
```

---

### **3. Перегрузка методов**

Перегрузка методов (overloading) — это определение нескольких методов с одинаковым именем, но разной сигнатурой (количеством или типами параметров).

#### **Особенности перегрузки**
- Методы должны отличаться **сигнатурой** (типами, количеством или порядком параметров).
- Перегрузка может использоваться как в одном классе, так и в производных.

#### Пример:
```csharp
public class Calculator
{
    // Перегрузка метода Add
    public int Add(int a, int b)
    {
        return a + b;
    }

    public double Add(double a, double b)
    {
        return a + b;
    }

    public int Add(int a, int b, int c)
    {
        return a + b + c;
    }
}

Calculator calc = new Calculator();
Console.WriteLine(calc.Add(2, 3));        // Вывод: 5
Console.WriteLine(calc.Add(2.5, 3.1));    // Вывод: 5.6
Console.WriteLine(calc.Add(1, 2, 3));     // Вывод: 6
```

---

### **4. Перегрузка как частный случай полиморфизма**

#### **Полиморфизм**
- Полиморфизм (многоформенность) — это способность объекта принимать разные формы.
- **Компиляционный полиморфизм**: реализуется с помощью перегрузки методов.
- **Раннее связывание**: выбор версии метода происходит на этапе компиляции.

#### Пример полиморфизма через перегрузку:
```csharp
public class Printer
{
    public void Print(string message)
    {
        Console.WriteLine($"Message: {message}");
    }

    public void Print(int number)
    {
        Console.WriteLine($"Number: {number}");
    }

    public void Print(double value)
    {
        Console.WriteLine($"Value: {value}");
    }
}

Printer printer = new Printer();
printer.Print("Hello");   // Вывод: Message: Hello
printer.Print(42);        // Вывод: Number: 42
printer.Print(3.14);      // Вывод: Value: 3.14
```

---

### **5. Сравнение переопределения и перегрузки**

| **Параметр**          | **Переопределение**                            | **Перегрузка**                              |
|-----------------------|------------------------------------------------|---------------------------------------------|
| **Суть**              | Изменяет поведение метода базового класса.     | Реализует несколько методов с одним именем. |
| **Ключевые слова**    | `virtual`, `override`, `abstract`.             | Ключевые слова не требуются.               |
| **Связывание**        | Позднее (выполняется во время выполнения).     | Раннее (решается на этапе компиляции).      |
| **Пример**            | `public override void Speak()`                 | `public void Speak(int volume)`             |

---

### **6. Итог**
- Унаследованные методы могут быть использованы без изменений или переопределены для изменения поведения.
- Перегрузка методов предоставляет гибкость, позволяя использовать одно имя метода для разных операций.
- Переопределение и перегрузка вместе демонстрируют **полиморфизм** в C#: возможность изменять и адаптировать поведение методов в разных контекстах.